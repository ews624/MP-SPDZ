import pandas as pd
import math
import numpy as np
import mpc_math


sizeofK = 13
N =10
n = 0
eta = 0 
x =12

	

def lcm(sizeofK):
	arr =[]
	for i in range(sizeofK -1):
		arr.append(i+2)
	nparray = arr
	k =np.lcm.reduce(nparray)
	print_ln('%s',k)
	return k
	
def check_diff(x,i,sign):
	j =0
	diff = 1000
	for j in range(100):
		eta = .005*j*sign
		checker = ((2**i)*(1+eta))
		if(x ==checker):
			return eta
		abso = abs(x-checker)
		if(abso<diff):
			diff = abso
			besteta = eta
		j = j+1
	return besteta	
	
	
	
def find_n_eta(x):
	i = 0
	j = MemValue(0)
	@for_range(100)
	def f(i):
		print_ln('2^i is %s',2**1)
		if((2**j.reveal())==x):
			return i,0
		if((2**j.reveal())< x):
			if(x <(2**(j.reveal()+1))):
			
				midpoint = (2**j.reveal())*1.5
				if(x>(midpoint)):
					eta = check_diff(x,j.reveal()+1,-1)
					return (j.reveal()+1), eta
				if(x<(midpoint)):
					eta = check_diff(x,j.reveal(),1)
					return j.reveal(),eta
				else:
					return j.reveal(),.5
		#i = i+1
		j.write(j +1)
	return 0,0




k = lcm(sizeofK)
n,eta = find_n_eta(x)
print_ln('N is equal to %s and eta is equal is to %s',n,eta)
print_ln('%s = %s which is nice',x,(2**n)*(1+eta))
print_ln('%s is 2 to the power of 5', 2**5)



natural_log2 = math.log(2)



print_ln('The natural log of 2 is %s',natural_log2)







input = sint.Array(35)
#input.input_from(1)





sec_attr= Matrix(4,7,sint)

sec_attr.input_from(0)

a = sint(1)
b =sint(2)

fixed = sfix(10)



if((a <b).reveal()):
	print_ln('A is smaller than b')



sec_examples = sint.Matrix(7,5)
sec_examples.input_from(1)

if((a <sec_examples[3][4]).reveal()):
	print_ln('Matrix comparison works')



def sec_entropy(examples):
	total = sfix.MemValue(0)
	yescount = sfix.MemValue(0)
	nocount = MemValue(0)
	entropy = 0
	temp = sint(1)
	testing = sbit(1)
	counter = 0
	array = Array(10,sint)
	
	#for i in range(7):
	@for_range(7)
	def f(i):
		
		compvar = examples[i][4]
		if((temp<compvar).reveal()):
			#print_ln('compvar is bigger than 1')
			array[i] = 2
			yescount.write(yescount +1)
		else:
			array[i]= 1
			nocount.write(nocount+1)
		total.write(total+1)
		
	print_ln('Yes count is %s', yescount)
	print_ln('No count is %s', nocount)
	for i in range(7):
		print_ln('%s',array[i].reveal())
		#print_ln('memvalue is %s', yescount.reveal())
	
	if (nocount >0):
		print_ln('real entropy')
		#testval = sfix(0)
		#yessint = sfix(0)
		#yessint = sfix((yescount/total).reveal())
		#testval = sfix(mpc_math.log2_fx(yessint,2))
		print_ln('total is %s',total.reveal())
		#yespartial = yescount/total
		#print_ln('yes partial is %s', yespartial.reveal())
		#clearyes = yescount.reveal()
		#print_ln('clearyes is %s',clearyes)
		
		#yessfix = sfix(5)
		#logyes = mpc_math.log2_fx(yessfix)
		#print_ln('log is %s',mpc_math.log2_fx(yespartial))
		
		#yesreal = sint(yespartial.reveal())
		#yesfix = sfix(yesreal)
		#yeslog = mpc_math.log2_fx(yesfix.reveal())
		#entropy = ((yescount/total)*(math.log2(yescount/total)))-((nocount/total)*(math.log2(nocount/total)))
	else:
		yescount = 2
		nocount = 5
		total = 7
		print_ln('False entropy')
		entropy = ((yescount/total)*(math.log2(yescount/total)))-((nocount/total)*(math.log2(nocount/total)))
	return entropy
	
	
	
#print_ln('Entropy is %s',sec_entropy(sec_examples))


'''
jay = 0
for i in range(7):
	for j in range(5):
		twodim[i][j] = input[jay]
		jay = jay +1 
	

for i in range(7):
	for j in range(5):
		print_ln('%s',twodim[i][j].reveal())
'''


'''
@for_range(35)
def f(i):
	secretArray[i] = 



def secret_info_gain():
	print_ln()
	

def sec_entropy(examples):
	total = 0
	yescount = 0
	nocount = 0
	for i in range(7):
    		if(examples[4][i] == "1"):
    			nocount = nocount +1
    		else:
    			yescount= yescount +1
    		total = total +1
	entropy = ((yescount/total)*(log2(yescount/total)))-((nocount/total)*(log2(nocount/total)))

def sec_info_gain(examples, attr):
    uniq = np.unique(examples[attr])
    #print ("\n",uniq)
    gain = sec_entropy(examples)
    #print ("\n",gain)
    for u in uniq:
        subdata = examples[examples[attr] == u]
        #print ("\n",subdata)
        sub_e = sec_entropy(subdata)
        gain -= (float(len(subdata)) / float(len(examples))) * sub_e
        #print ("\n",gain)
    return gain
    	
def secret_ID3(examples, attrs):

    max_gain = 0
    max_feat = ""
    for feature in attrs:
        #print ("\n",examples)
        gain = sec_info_gain(examples, feature)
        if gain > max_gain:
            max_gain = gain
            max_feat = feature
    
    #print ("\nMax feature attr",max_feat)

'''



'''
data = pd.read_csv("3-dataset.csv")
features = [feat for feat in data]
features.remove("answer")

class Node:
    def __init__(self):
        self.children = []
        self.value = ""
        self.isLeaf = False
        self.pred = ""

def entropy(examples):
    pos = 0.0
    neg = 0.0
    for _, row in examples.iterrows():
        if row["answer"] == "yes":
            pos += 1
        else:
            neg += 1
    if pos == 0.0 or neg == 0.0:
        return 0.0
    else:
        p = pos / (pos + neg)
        n = neg / (pos + neg)
        return -(p * math.log(p, 2) + n * math.log(n, 2))

def info_gain(examples, attr):
    uniq = np.unique(examples[attr])
    #print ("\n",uniq)
    gain = entropy(examples)
    #print ("\n",gain)
    for u in uniq:
        subdata = examples[examples[attr] == u]
        #print ("\n",subdata)
        sub_e = entropy(subdata)
        gain -= (float(len(subdata)) / float(len(examples))) * sub_e
        #print ("\n",gain)
    return gain

def ID3(examples, attrs):
    root = Node()

    max_gain = 0
    max_feat = ""
    for feature in attrs:
        #print ("\n",examples)
        gain = info_gain(examples, feature)
        if gain > max_gain:
            max_gain = gain
            max_feat = feature
    root.value = max_feat
    #print ("\nMax feature attr",max_feat)
    uniq = np.unique(examples[max_feat])
    #print ("\n",uniq)
    for u in uniq:
        #print ("\n",u)
        subdata = examples[examples[max_feat] == u]
        #print ("\n",subdata)
        if entropy(subdata) == 0.0:
            newNode = Node()
            newNode.isLeaf = True
            newNode.value = u
            newNode.pred = np.unique(subdata["answer"])
            root.children.append(newNode)
        else:
            dummyNode = Node()
            dummyNode.value = u
            new_attrs = attrs.copy()
            new_attrs.remove(max_feat)
            child = ID3(subdata, new_attrs)
            dummyNode.children.append(child)
            root.children.append(dummyNode)
    return root

def printTree(root: Node, depth=0):
    for i in range(depth):
        print("\t", end="")
    print(root.value, end="")
    if root.isLeaf:
        print(" -> ", root.pred)
    print()
    for child in root.children:
        printTree(child, depth + 1)

root = ID3(data, features)
printTree(root)

'''

'''
print_ln('Ethans test')

testarray = [[1,1,1,1,0],[1,1,1,2,0],[2,1,1,1,1]]

print_ln('Ethans 2d array:')
#for i in testarray:
#	print_ln(i)

#print_ln('%s',testarray)



'''
'''
party1array = []
party0array = []

for i in range(4):
	party0array.append(sint.get_raw_input_from(0))

#for i in range(4):
#	party1array.append(sint.get_raw_input_from(1))
fullarray = []
for i in range(2):
	party1array = []
	for j in range(5):
		party1array.append(sint.get_raw_input_from(1))
	fullarray.append(party1array)
	
	
	
	
#for i in range(len(party1array)):
#	print_ln('Array value at index %s is %s',i, party1array[i].reveal())	
for i in range(2):
	for j in range(5):
		print_ln('%s',fullarray[i][j].reveal())	
'''	

'''
print_ln('Ethans test')

a = sint(1)
b = sint(2)

def test(actual, expected):

    # you can reveal a number in order to print it

    actual = actual.reveal()
    print_ln('expected %s, got %s', expected, actual)
'''

#test(a + b, 3)


'''
for i in 0, 1:
    print_ln('got %s from player %s', sint.get_input_from(i).reveal(), i)

# some arithmetic works as expected

test(a + b, 3)
test(a * b, 2)
test(a - b, -1)

# Division can mean different things in different domains
# and there has be a specified bit length in some,
# so we use int_div() for integer division.
# k-bit division requires (4k+1)-bit computation.

test(b.int_div(a, 15), 2)

# comparisons produce 1 for true and 0 for false

test(a < b, 1)
test(a <= b, 1)
test(a >= b, 0)
test(a > b, 0)
test(a == b, 0)
test(a != b, 1)

# if_else() can be used instead of branching
# let's find out the larger number
test((a < b).if_else(b, a), 2)

# arrays and loops work as follows

a = Array(100, sint)

@for_range(100)
def f(i):
    a[i] = sint(i) * sint(i - 1)

test(a[99], 99 * 98)

# if you use loops, use Array to store results
# don't do this
# @for_range(100)
# def f(i):
#     a = sint(i)
# test(a, 99)

# sfix: fixed-point numbers

# set the precision after the dot and in total

sfix.set_precision(16, 31)

# and the output precision in decimal digits

print_float_precision(4)

# you can do all basic arithmetic with sfix, including division

a = sfix(2)
b = sfix(-0.1)

test(a + b, 1.9)
test(a - b, 2.1)
test(a * b, -0.2)
test(a / b, -20)
test(a < b, 0)
test(a <= b, 0)
test(a >= b, 1)
test(a > b, 1)
test(a == b, 0)
test(a != b, 1)

test((a < b).if_else(a, b), -0.1)

# now let's do a computation with private inputs
# party 0 supplies three number and party 1 supplies three percentages
# we want to compute the weighted mean

print_ln('Party 0: please input three numbers not adding up to zero')
print_ln('Party 1: please input any three numbers')

data = Matrix(3, 2, sfix)

# use @for_range_opt for balanced optimization
# but use Python loops if compile-time numbers are need (e.g., for players)

@for_range_opt(3)
def _(i):
    for j in range(2):
        data[i][j] = sfix.get_input_from(j)

# compute weighted average

weight_total = sum(point[0] for point in data)
result = sum(point[0] * point[1] for point in data) / weight_total

# branching is supported also depending on revealed secret data
# with garbled circuits this triggers a interruption of the garbling

@if_e((sum(point[0] for point in data) != 0).reveal())
def _():
    print_ln('weighted average: %s', result.reveal())
@else_
def _():
    print_ln('your inputs made no sense')

# permutation matrix

M = Matrix(2, 2, sfix)
M[0][0] = 0
M[1][0] = 1
M[0][1] = 1
M[1][1] = 0

# matrix multiplication

M = data * M
test(M[0][0], data[0][1].reveal())
test(M[1][1], data[1][0].reveal())

'''




