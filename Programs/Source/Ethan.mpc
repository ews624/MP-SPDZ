import pandas as pd
import math
import numpy as np
# sint: secret integers

# you can assign public numbers to sint

input = sint.Array(35)
#input.input_from(1)





sec_attr= Matrix(4,7,sint)

sec_attr.input_from(0)

a = sint(1)
b =sint(2)


if((a <b).reveal()):
	print_ln('A is smaller than b')



sec_examples = sint.Matrix(7,5)
sec_examples.input_from(1)

if((a <sec_examples[3][4])):
	print_ln('Matrix comparison works')


'''
def sec_entropy(examples):
	total = 0
	yescount = 0
	nocount = 0
	entropy = 0
	temp = sint(1)
	testing = sbit(1)
	counter = 0
	array = []
	for i in range(7):
		
		nonlocal total
		global nocount
		nonlocal counter
		testvar = examples[i][4].reveal()
		
		print_ln('REvealed matrix value is %s',testvar.reveal())
		
		if((temp <examples[i][4]).reveal()):
			array.append(0)
			#nocount = nocount +1
			#print_ln('No count is %s',nocount)
			print_ln('temp is less')
		else:
			array.append(1)
			#yescount =yescount + 1
		total = total + 1
		print_ln('Total count is %s', total)
		
	print_ln('Yes count is %s', yescount)
	print_ln('No count is %s', nocount)
	for i in range(len(array)):
		print_ln('%s',array[i])
	if (yescount > 0 and nocount >0):
		entropy = ((yescount/total)*(math.log2(yescount/total)))-((nocount/total)*(math.log2(nocount/total)))
	else:
		yescount = 2
		nocount = 5
		total = 7
		print_ln('False entropy')
		entropy = ((yescount/total)*(math.log2(yescount/total)))-((nocount/total)*(math.log2(nocount/total)))
	return entropy
	
	
	
print_ln('%s',sec_entropy(sec_examples))

'''
'''
jay = 0
for i in range(7):
	for j in range(5):
		twodim[i][j] = input[jay]
		jay = jay +1 
	

for i in range(7):
	for j in range(5):
		print_ln('%s',twodim[i][j].reveal())
'''


'''
@for_range(35)
def f(i):
	secretArray[i] = 



def secret_info_gain():
	print_ln()
	

def sec_entropy(examples):
	total = 0
	yescount = 0
	nocount = 0
	for i in range(7):
    		if(examples[4][i] == "1"):
    			nocount = nocount +1
    		else:
    			yescount= yescount +1
    		total = total +1
	entropy = ((yescount/total)*(log2(yescount/total)))-((nocount/total)*(log2(nocount/total)))

def sec_info_gain(examples, attr):
    uniq = np.unique(examples[attr])
    #print ("\n",uniq)
    gain = sec_entropy(examples)
    #print ("\n",gain)
    for u in uniq:
        subdata = examples[examples[attr] == u]
        #print ("\n",subdata)
        sub_e = sec_entropy(subdata)
        gain -= (float(len(subdata)) / float(len(examples))) * sub_e
        #print ("\n",gain)
    return gain
    	
def secret_ID3(examples, attrs):

    max_gain = 0
    max_feat = ""
    for feature in attrs:
        #print ("\n",examples)
        gain = sec_info_gain(examples, feature)
        if gain > max_gain:
            max_gain = gain
            max_feat = feature
    
    #print ("\nMax feature attr",max_feat)

'''



'''
data = pd.read_csv("3-dataset.csv")
features = [feat for feat in data]
features.remove("answer")

class Node:
    def __init__(self):
        self.children = []
        self.value = ""
        self.isLeaf = False
        self.pred = ""

def entropy(examples):
    pos = 0.0
    neg = 0.0
    for _, row in examples.iterrows():
        if row["answer"] == "yes":
            pos += 1
        else:
            neg += 1
    if pos == 0.0 or neg == 0.0:
        return 0.0
    else:
        p = pos / (pos + neg)
        n = neg / (pos + neg)
        return -(p * math.log(p, 2) + n * math.log(n, 2))

def info_gain(examples, attr):
    uniq = np.unique(examples[attr])
    #print ("\n",uniq)
    gain = entropy(examples)
    #print ("\n",gain)
    for u in uniq:
        subdata = examples[examples[attr] == u]
        #print ("\n",subdata)
        sub_e = entropy(subdata)
        gain -= (float(len(subdata)) / float(len(examples))) * sub_e
        #print ("\n",gain)
    return gain

def ID3(examples, attrs):
    root = Node()

    max_gain = 0
    max_feat = ""
    for feature in attrs:
        #print ("\n",examples)
        gain = info_gain(examples, feature)
        if gain > max_gain:
            max_gain = gain
            max_feat = feature
    root.value = max_feat
    #print ("\nMax feature attr",max_feat)
    uniq = np.unique(examples[max_feat])
    #print ("\n",uniq)
    for u in uniq:
        #print ("\n",u)
        subdata = examples[examples[max_feat] == u]
        #print ("\n",subdata)
        if entropy(subdata) == 0.0:
            newNode = Node()
            newNode.isLeaf = True
            newNode.value = u
            newNode.pred = np.unique(subdata["answer"])
            root.children.append(newNode)
        else:
            dummyNode = Node()
            dummyNode.value = u
            new_attrs = attrs.copy()
            new_attrs.remove(max_feat)
            child = ID3(subdata, new_attrs)
            dummyNode.children.append(child)
            root.children.append(dummyNode)
    return root

def printTree(root: Node, depth=0):
    for i in range(depth):
        print("\t", end="")
    print(root.value, end="")
    if root.isLeaf:
        print(" -> ", root.pred)
    print()
    for child in root.children:
        printTree(child, depth + 1)

root = ID3(data, features)
printTree(root)

'''


print_ln('Ethans test')

testarray = [[1,1,1,1,0],[1,1,1,2,0],[2,1,1,1,1]]

print_ln('Ethans 2d array:')
#for i in testarray:
#	print_ln(i)

#print_ln('%s',testarray)
'''
party1array = []
party0array = []

for i in range(4):
	party0array.append(sint.get_raw_input_from(0))

#for i in range(4):
#	party1array.append(sint.get_raw_input_from(1))
fullarray = []
for i in range(2):
	party1array = []
	for j in range(5):
		party1array.append(sint.get_raw_input_from(1))
	fullarray.append(party1array)
	
	
	
	
#for i in range(len(party1array)):
#	print_ln('Array value at index %s is %s',i, party1array[i].reveal())	
for i in range(2):
	for j in range(5):
		print_ln('%s',fullarray[i][j].reveal())	
'''	
print_ln('Ethans test')

a = sint(1)
b = sint(2)

def test(actual, expected):

    # you can reveal a number in order to print it

    actual = actual.reveal()
    print_ln('expected %s, got %s', expected, actual)


#test(a + b, 3)


'''
for i in 0, 1:
    print_ln('got %s from player %s', sint.get_input_from(i).reveal(), i)

# some arithmetic works as expected

test(a + b, 3)
test(a * b, 2)
test(a - b, -1)

# Division can mean different things in different domains
# and there has be a specified bit length in some,
# so we use int_div() for integer division.
# k-bit division requires (4k+1)-bit computation.

test(b.int_div(a, 15), 2)

# comparisons produce 1 for true and 0 for false

test(a < b, 1)
test(a <= b, 1)
test(a >= b, 0)
test(a > b, 0)
test(a == b, 0)
test(a != b, 1)

# if_else() can be used instead of branching
# let's find out the larger number
test((a < b).if_else(b, a), 2)

# arrays and loops work as follows

a = Array(100, sint)

@for_range(100)
def f(i):
    a[i] = sint(i) * sint(i - 1)

test(a[99], 99 * 98)

# if you use loops, use Array to store results
# don't do this
# @for_range(100)
# def f(i):
#     a = sint(i)
# test(a, 99)

# sfix: fixed-point numbers

# set the precision after the dot and in total

sfix.set_precision(16, 31)

# and the output precision in decimal digits

print_float_precision(4)

# you can do all basic arithmetic with sfix, including division

a = sfix(2)
b = sfix(-0.1)

test(a + b, 1.9)
test(a - b, 2.1)
test(a * b, -0.2)
test(a / b, -20)
test(a < b, 0)
test(a <= b, 0)
test(a >= b, 1)
test(a > b, 1)
test(a == b, 0)
test(a != b, 1)

test((a < b).if_else(a, b), -0.1)

# now let's do a computation with private inputs
# party 0 supplies three number and party 1 supplies three percentages
# we want to compute the weighted mean

print_ln('Party 0: please input three numbers not adding up to zero')
print_ln('Party 1: please input any three numbers')

data = Matrix(3, 2, sfix)

# use @for_range_opt for balanced optimization
# but use Python loops if compile-time numbers are need (e.g., for players)

@for_range_opt(3)
def _(i):
    for j in range(2):
        data[i][j] = sfix.get_input_from(j)

# compute weighted average

weight_total = sum(point[0] for point in data)
result = sum(point[0] * point[1] for point in data) / weight_total

# branching is supported also depending on revealed secret data
# with garbled circuits this triggers a interruption of the garbling

@if_e((sum(point[0] for point in data) != 0).reveal())
def _():
    print_ln('weighted average: %s', result.reveal())
@else_
def _():
    print_ln('your inputs made no sense')

# permutation matrix

M = Matrix(2, 2, sfix)
M[0][0] = 0
M[1][0] = 1
M[0][1] = 1
M[1][1] = 0

# matrix multiplication

M = data * M
test(M[0][0], data[0][1].reveal())
test(M[1][1], data[1][0].reveal())

'''




