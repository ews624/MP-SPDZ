import math
import mpc_math

sfix.set_precision(16,32)

## NOTE: DATA columns in order from left to right are
# Color, Outline, Dot, Shape


class Tree:
	def __init__(self):
		self.left = None
		self.center = None
		self.right = None
		self.attribute = None
		self.data = None

def first_entropy(examples, count,range):
	total = sfix.MemValue(0)
	entropy = sfix.MemValue(0)
	different_attri = Array(3,sfix)
	different_attri.assign_all(0)
	x = sfix(0)
	biggest = sint.MemValue(0)
	@for_range_opt(range)
	def f(i):
		compvar = examples[i][count]
		different_attri[compvar.reveal()-1] =  different_attri[compvar.reveal()-1] +1

		f = (biggest < compvar)
		biggest.write((compvar*f)+(biggest*(sint(1)-f)))
		total.write(total+1)

	@for_range_opt(biggest.reveal())
	def W(i):

		x = different_attri[i]/sfix(total)
		entropy.write(entropy -(x*(mpc_math.log2_fx(x))))

	return entropy


def get_gain(EntroValue,attri_count,Comparison_Entropy,numerator,range):

	sum_of_Entro = sfix.MemValue(0.0)
	@for_range_opt(attri_count)
	def tr(i):
		sum_of_Entro.write(((numerator[i]/range)*EntroValue[i])+ sum_of_Entro)
	gain = Comparison_Entropy - sfix(sum_of_Entro)

	return gain

def sec_entropy(examples,Comparison_Entropy,column_number,range):
	different_attri = Array(10,sfix)
	temp = sint(1)
	lastint = sint(0)
	skip = 0
	mover = sfix(0.0)
	different_attri.assign_all(0)
	x = sfix(0)
	array = Array(14,sint)
	shape_array = Array(10,sfix)
	shape_array.assign_all(0)
	gain = sfix(0.0)
	biggest = sint.MemValue(1)
	@for_range_opt(range)
	def f(i):
		compvar = examples[i][column_number]
		lastvar = examples[i][3]
		different_attri[compvar.reveal()-1] =  different_attri[compvar.reveal()-1] +1

		lastint = (lastvar == temp)
		mover = sfix(lastint)

		shape_array[compvar.reveal()-1] = shape_array[compvar.reveal()-1] + mover

		f = (biggest < compvar)
		biggest.write((compvar*f)+(biggest*(sint(1)-f)))

		if((sint(0) < sint(1)).reveal()):
			skip = 0

	return_Array = Array(3,sfix)

	@for_range_opt(biggest.reveal())
	def W(i):
		denom = different_attri[i]

		top = shape_array[i]
		x = top/denom

		rest = denom-top
		rest = rest/denom
		#print_ln('rest is %s',rest.reveal())
		partone = (x*mpc_math.log2_fx(x))
		#print_ln('partone is %s',partone.reveal())
		parttwo = (rest*mpc_math.log2_fx(rest))
		#print_ln('parttwo is %s',parttwo.reveal())
		return_Array[i] = (-partone)+(-parttwo)
		#print_ln('return_Array is %s',return_Array[i].reveal())

	gain = get_gain(return_Array,biggest.reveal(),Comparison_Entropy,different_attri,range)
	print_ln('Gain is %s',gain.reveal())
	return gain

def gainChecker(squares,triangles,totalofColor,root,shamir_input,ColorInt):
	latestEntro = sfix.MemValue(0.0)
	print_ln('in gainchecker num of squares is %s,triangles %s',squares.reveal(),triangles.reveal())

	root.center = Tree()
	root.right = Tree()

	squares = sfix(squares)
	triangles = sfix(triangles)
	totalofColor = sfix(totalofColor)
	x = sfix(squares/totalofColor)
	y = sfix(triangles/totalofColor)
	latestEntro = (-(x*mpc_math.log2_fx(x))-(y*(mpc_math.log2_fx(y))))
	print_ln('latestEntro is %s',latestEntro.reveal())
	totaldots = sint.MemValue(0)
	totaldashed = sint.MemValue(0)
	total = sfix.MemValue(0)
	color = sint(ColorInt)
	#create deeper nodes
	@for_range_opt(42)
	def _(i):

		colorCheck = (shamir_input[i][0]== color)
		f = (sint(1)==shamir_input[i][2])
		f = (f*colorCheck)
		totaldots.write(totaldots+f)
		f = (sint(1)==shamir_input[i][1])
		f = (f*colorCheck)
		totaldashed.write(totaldashed+f)

		total.write(total+colorCheck)

	print_ln('totaldots is %s',totaldots.reveal())
	print_ln('totaldashed is %s',totaldashed.reveal())


	x = sfix(totaldots/total)
	mid = sfix(sfix(total)-sfix(totaldots))
	y = sfix(mid/sfix(total))
	entroOne = (-(x*mpc_math.log2_fx(x))-(y*(mpc_math.log2_fx(y))))

	x = sfix(totaldashed/total)
	mid = sfix(sfix(total)-sfix(totaldashed))
	y = sfix(mid/sfix(total))
	entrotwo = (-(x*mpc_math.log2_fx(x))-(y*(mpc_math.log2_fx(y))))

	entroOne = latestEntro - entroOne
	entrotwo = latestEntro - entrotwo

	f = (entroOne > entrotwo)
	mover = ((f*entroOne)+(entrotwo*(1-f)))
	root.center.data = mover.reveal()
	mover = (((1-f)*entroOne)+(f*entrotwo))
	root.right.data = mover.reveal()




def nodeGetter(range,allEntro,root,shamir_input,ColorInt):
	f = sint(-1)
	smallestEntro = sfix.MemValue(10.0)
	smallestindex = sint.MemValue(100)
	print_ln('')

	@for_range_opt(3)
	def _(i):
		f = (smallestEntro > allEntro[i])
		smallestindex.write((f*i)+ (smallestindex*(sint(1)-f)))
		smallestEntro.write((allEntro[i]*f)+ (smallestEntro*(sint(1)-f)))
		#print_ln('smallestEntro is %s, allEntro is %s',smallestEntro.reveal(),allEntro[i].reveal())
	print_ln('smallest index is %s which is %s',smallestindex.reveal(),allEntro[smallestindex.reveal()].reveal())
	root.left = Tree()

	#yellow = 2
	#green = 1
	#red = 3
	squares = sint.MemValue(0)
	triangles = sint.MemValue(0)
	totalcolor = sint.MemValue(0)

	@for_range_opt(42)
	def _(j):
		f = (ColorInt ==shamir_input[j][0])
		totalcolor.write(((totalcolor+1)*f)+(totalcolor*(sint(1)-f)))
		l = (sint(2) == shamir_input[j][3])
		squares.write(squares + (f*l))
		l = (sint(1) == shamir_input[j][3])
		triangles.write(triangles+(l*f))

	gainChecker(squares,triangles,totalcolor,root,shamir_input,ColorInt)
	root.left.data = smallestEntro.reveal()
	print_ln('root left data is %s',root.left.data)
	print_ln('root center data is %s',root.center.data)
	print_ln('root right data is %s',root.right.data)
	return smallestindex

def first_layer_tree(maxindex,shamir_input):

	yellowCount = sint.MemValue(0)
	redCount = sint.MemValue(0)
	greenCount = sint.MemValue(0)

	yellowTri = sint.MemValue(0)
	redTri = sint.MemValue(0)
	greenTri = sint.MemValue(0)


	yellowEntro = sfix(0.0)
	redEntro = sfix(0.0)
	greenEntro = sfix(0.0)

	allEntro = Array(3,sfix)

	column = maxindex.reveal()
	@for_range_opt(42)
	def _(i):
		tester = shamir_input[i][column]
		shape = shamir_input[i][3]
		y = (sint(2)== tester)
		r = (sint(3) == tester)
		g = (sint(1)== tester)

		yT = (y == shape)
		rT = (r == shape)
		gT = (g == shape)

		yellowTri.write(yellowTri + yT)
		redTri.write(redTri + rT)
		greenTri.write(greenTri + gT)

		yellowCount.write(yellowCount + y)
		redCount.write(redCount + r)
		greenCount.write(greenCount + g)

	top = sfix(yellowTri)
	bot = sfix(yellowCount)

	x = sfix(top/bot)
	difference = (bot - top)
	y = sfix(difference/bot)
	ans = (-(x*mpc_math.log2_fx(x))-(y*mpc_math.log2_fx(y)))
	yellowEntro = ans


	top = sfix(redTri)
	bot = sfix(redCount)

	x = sfix(top/bot)
	difference = (bot- top)
	y = sfix(difference/bot)
	ans = sfix((-(x*mpc_math.log2_fx(x)))+(-(y*mpc_math.log2_fx(y))))
	redEntro = ans

	top = sfix(greenTri)
	bot = sfix(greenCount)

	x = sfix(top/bot)
	difference = (bot-top)
	y = sfix(difference/bot)
	ans = (-(x*(mpc_math.log2_fx(x)))-(y*(mpc_math.log2_fx(y))))
	greenEntro = ans

	allEntro[0] = yellowEntro
	allEntro[1] = redEntro
	allEntro[2] = greenEntro

	root = Tree()
	root.data = 'Color'

	root.left = Tree()
	smallestindex = sint(0)
	smallestindex  =nodeGetter(range,allEntro,root.left,shamir_input,2)



	loopArray = Array(3,sfix)
	@for_range_opt(3)
	def _(t):
		f = (t == smallestindex).if_else(sfix(9.0),allEntro[t])
		loopArray[t] = f

	print_ln('loopArray at 0 is %s',loopArray[0].reveal())
	print_ln("root data is %s",root.data)
	print_ln("root left data is %s",root.left.data)

	root.center = Tree()
	#for red
	smallestindex  =nodeGetter(range,loopArray,root.center,shamir_input,3)


	newArray = Array(3,sfix)



	@for_range_opt(3)
	def _(t):
		f = (t == smallestindex).if_else(sfix(9.0),loopArray[t])
		newArray[t] = f
	#print_ln('root left data is %s',root.right.left.data)

	newArray[smallestindex.reveal()] = sfix(9.0)

	newestArray = Array(3,sfix)
	newestArray[0] = newArray[0]
	newestArray[1] = sfix(9.0)
	newestArray[2] = newArray[2]

	#print_ln('allentro at index 1 is %s and index 2 is %s',Entro[1].reveal(),allEntro[2].reveal())
	print_ln("Root center left data is %s",root.center.left.data)

	root.right = Tree()

	smallestindex  =nodeGetter(range,newArray,root.right,shamir_input,1)

	root.right.left.attribute = "Green"
	print_ln("Root right left data is %s",root.right.left.data)
	print_ln("Root right left attribute is %s",root.right.left.attribute)


	#print_ln('smallestEntro is %s',smallestEntro.reveal())
	print_ln("amount of yellow is %s",yellowCount.reveal())
	print_ln('yellow entropy is %s',yellowEntro.reveal())
	print_ln('green entropy is %s',greenEntro.reveal())
	print_ln('red entropy is %s',redEntro.reveal())

	#find of color then next highest gain Attribute(outline)


p0_inputs = sint.Matrix(14,4)
p0_inputs.input_from(0)

p1_inputs = sint.Matrix(14,4)
p1_inputs.input_from(1)

p2_inputs = sint.Matrix(14,4)
p2_inputs.input_from(2)

shamir_input = sint.Matrix(42,4)

@for_range_parallel(3,[14,4])
def hi(i,j):
	shamir_input[i][j] = p0_inputs[i][j]
	shamir_input[i+14][j] = p1_inputs[i][j]
	shamir_input[i+28][j] = p2_inputs[i][j]


EntroArray = Array(4,sfix)
total_shamir_array = Array(4,sfix)
@for_range_opt(4)
def fl(i):
	total_shamir_array[i] = first_entropy(shamir_input,i,42)
	print_ln('Total shamir array is %s', total_shamir_array[i].reveal())


max_Initial_Entro = sfix.MemValue(0.0)
f = sint(-1)

maxindex = sint.MemValue(0)
@for_range_opt(4)
def fl(i):
	f = (max_Initial_Entro < total_shamir_array[i])
	maxindex.write((f*i) + (maxindex*(sint(1)-f)))
	max_Initial_Entro.write( (total_shamir_array[i]*f)+ (max_Initial_Entro*(sint(1)-f)))
print_ln('max index is %s which is %s',maxindex.reveal(),max_Initial_Entro.reveal())

Comparison_Entropy = total_shamir_array[3]

gain_array = Array(3,sfix)
@for_range_opt(3)
def gainAll(i):
	gain_array[i]= sec_entropy(shamir_input,Comparison_Entropy,i,42)



f = sint(-1)
largestGain = sfix.MemValue(0.0)
maxindex = sint.MemValue(0)
@for_range_opt(3)
def _(i):
	f = (largestGain < gain_array[i])
	maxindex.write((f*i)+ (maxindex*(sint(1)-f)))
	largestGain.write((gain_array[i]*f)+ (largestGain*(sint(1)-f)))
print_ln('largest gain index is %s which is %s',maxindex.reveal(),gain_array[maxindex.reveal()].reveal())

print_ln('')
print_ln('')
print_ln('')
first_layer_tree(maxindex,shamir_input)
